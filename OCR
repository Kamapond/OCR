#Mistral OCR sample

from __future__ import annotations
import os, json, base64, hashlib
from pathlib import Path
from typing import Iterable, Any, List, Dict
from datetime import datetime

# ===== TLS / è¨¼æ˜Žæ›¸å¯¾ç­–ï¼ˆç¤¾å†…CAå¯¾å¿œï¼‰ =====
import certifi
try:
    import certifi_win32  # noqa: F401
except Exception:
    pass
os.environ.setdefault("SSL_CERT_FILE", certifi.where())
try:
    import truststore
    truststore.inject_into_ssl()
except Exception:
    pass

# ===== ãƒ©ã‚¤ãƒ–ãƒ©ãƒª =====
import httpx
from mistralai import Mistral
from dotenv import load_dotenv, find_dotenv

# ===== å…¥å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ =====
INPUT_DIR = Path(
    r"C:\Users\smatsuzono\Documents\ZETEC\Personal Space\PersonalPersonal\MBA\!èª²é¡Œç ”ç©¶\ðŸ§Šãƒ‡ãƒ¼ã‚¿\æœ¬\JSNDI\UT_lv3\JPG"
)
OUTPUT_DIR = INPUT_DIR.parent / "_ocr_json"
OUTPUT_JSON = OUTPUT_DIR / "combined_pages.json"
RECURSIVE = False
TEST_LIMIT: int | None = None  # å‹•ä½œç¢ºèªæ™‚ã¯å°ã•ãªæ•°ã€é€šå¸¸ã¯ None

# ===== Mistral OCR =====
MODEL_NAME = "mistral-ocr-latest"
INCLUDE_IMAGE_BASE64 = False

# ===== .env ã®å ´æ‰€ï¼ˆAgent\.env å„ªå…ˆï¼‰ =====
ENV_PATH = Path(r"C:\Users\smatsuzono\Documents\ZETEC\Python\Agent\.env")

# ===== å¯¾è±¡æ‹¡å¼µå­ =====
EXTS = [".jpg", ".jpeg", ".png", ".tif", ".tiff", ".JPG", ".JPEG", ".PNG", ".TIF", ".TIFF"]


# -------- Utils --------
def iter_images(dir_path: Path, recursive: bool = False) -> Iterable[Path]:
    if recursive:
        for ext in EXTS:
            yield from dir_path.rglob(f"*{ext}")
    else:
        for ext in EXTS:
            yield from dir_path.glob(f"*{ext}")

def file_sha256(path: Path, buf_size: int = 1024 * 1024) -> str:
    h = hashlib.sha256()
    with path.open("rb") as f:
        while True:
            b = f.read(buf_size)
            if not b:
                break
            h.update(b)
    return h.hexdigest()

def to_data_uri(img_path: Path) -> str:
    b = img_path.read_bytes()
    b64 = base64.b64encode(b).decode("utf-8")
    ext = img_path.suffix.lower()
    if ext in (".jpg", ".jpeg"):
        mime = "image/jpeg"
    elif ext in (".png",):
        mime = "image/png"
    elif ext in (".tif", ".tiff"):
        mime = "image/tiff"
    else:
        mime = "application/octet-stream"
    return f"data:{mime};base64,{b64}"

def extract_markdown_from_ocr_response(ocr_response: Any) -> str:
    """
    client.ocr.process(...) ã®è¿”ã‚Šå€¤ã‹ã‚‰ pages[].markdown ã‚’çµåˆã—ã¦è¿”ã™ã€‚
    """
    pages = []
    if isinstance(ocr_response, dict):
        pages = ocr_response.get("pages") or []
    else:
        pages = getattr(ocr_response, "pages", []) or []
    chunks = []
    for p in pages:
        if isinstance(p, dict):
            md = p.get("markdown", "") or ""
        else:
            md = getattr(p, "markdown", "") or ""
        if md:
            chunks.append(md)
    return "\n\n".join(chunks).strip()


# -------- Main --------
def main():
    # .env èª­ã¿è¾¼ã¿ï¼ˆAgent\.env ã‚’æœ€å„ªå…ˆï¼‰
    if ENV_PATH.exists():
        load_dotenv(dotenv_path=ENV_PATH, override=False)
    else:
        found = find_dotenv(usecwd=True)
        if found:
            load_dotenv(found, override=False)

    api_key = os.environ.get("MISTRAL_API_KEY")
    if not api_key:
        raise RuntimeError("MISTRAL_API_KEY ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚Agent\\.env ã«è¨­å®šã—ã¦ãã ã•ã„ã€‚")

    if not INPUT_DIR.exists():
        raise FileNotFoundError(f"å…¥åŠ›ãƒ•ã‚©ãƒ«ãƒ€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {INPUT_DIR}")

    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    # SDK ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
    client = Mistral(api_key=api_key)

    # TLS ç–Žé€šï¼ˆ401 expectedï¼‰
    try:
        r = httpx.head("https://api.mistral.ai/v1/models", timeout=10.0, verify=certifi.where())
        print("TLS check:", r.status_code)
    except Exception as e:
        print("TLS check failed:", e)

    # ç”»åƒåˆ—æŒ™
    images = sorted(iter_images(INPUT_DIR, recursive=RECURSIVE), key=lambda p: p.name.lower())
    if TEST_LIMIT:
        images = images[:TEST_LIMIT]
    if not images:
        print(f"ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ: {INPUT_DIR}")
        return

    print(f"æ¤œå‡ºãƒ•ã‚¡ã‚¤ãƒ«æ•°: {len(images)}")

    # é‡è¤‡æŽ’é™¤ï¼ˆå†…å®¹ãƒãƒƒã‚·ãƒ¥ã§åˆ¤å®šï¼‰
    unique_images: List[Path] = []
    seen_hashes: set[str] = set()
    for p in images:
        try:
            h = file_sha256(p)
        except Exception as e:
            print(f"[SKIP] ãƒãƒƒã‚·ãƒ¥è¨ˆç®—å¤±æ•—: {p} -> {e}")
            continue
        if h in seen_hashes:
            print(f"[DEDUP] åŒä¸€å†…å®¹ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—: {p.name}")
            continue
        seen_hashes.add(h)
        unique_images.append(p)

    print(f"OCRå¯¾è±¡ï¼ˆé‡è¤‡é™¤åŽ»å¾Œï¼‰: {len(unique_images)}")

    combined_pages: List[Dict[str, Any]] = []

    for idx, img in enumerate(unique_images, start=1):
        # ãƒ­ã‚°ã¯ç›¸å¯¾è¡¨è¨˜ï¼ˆä»»æ„ï¼‰
        try:
            rel = img.relative_to(INPUT_DIR)
        except Exception:
            rel = img.name
        print(f"[OCR] ({idx}/{len(unique_images)}) {rel}")

        try:
            data_uri = to_data_uri(img)
            ocr_response = client.ocr.process(
                model=MODEL_NAME,
                document={"type": "image_url", "image_url": data_uri},
                include_image_base64=INCLUDE_IMAGE_BASE64,
            )
        except Exception as e:
            print(f"  -> SKIP: API ERROR: {e}")
            # å¤±æ•—æ™‚ã¯ãã®ãƒšãƒ¼ã‚¸ã‚’é£›ã°ã™ï¼ˆå¿…è¦ãªã‚‰ç©ºãƒšãƒ¼ã‚¸ã‚’æŒ¿å…¥ã—ã¦ã‚‚ã‚ˆã„ï¼‰
            continue

        md_text = extract_markdown_from_ocr_response(ocr_response)
        if not md_text:
            print("  -> WARN: markdown empty")

        combined_pages.append({
            "page": idx,
            "markdown": md_text
        })

    # çµ±åˆJSONã‚’æ›¸ãå‡ºã—ï¼ˆæœ€å°æ§‹æˆï¼‰
    combined_payload = {
        "summary": { "count": len(combined_pages) },
        "pages": combined_pages
    }
    OUTPUT_JSON.write_text(json.dumps(combined_payload, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"å®Œäº†: {len(combined_pages)}/{len(unique_images)} ä»¶ -> {OUTPUT_JSON}")

if __name__ == "__main__":
    main()
